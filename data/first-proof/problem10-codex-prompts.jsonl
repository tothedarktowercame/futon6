{"node_id": "p10-problem", "node_type": "question", "prompt": "You are a mathematical proof verifier with expertise in numerical linear algebra, tensor decomposition, and RKHS methods.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Use only provided local context; do not perform web search.\n\n## Proof Step Under Review\n\n**Node ID**: p10-problem\n**Type**: question\n**Claim**: Given [(Z⊗K_tau)ᵀSS'(Z⊗K_tau) + λ(Iᵣ⊗K_tau)]vec(W) = (Iᵣ⊗K_tau)vec(B), with K_tau = K + τI and λ>0, explain how PCG solves this without O(N) computation.\n\n## Verification Focus\n\nVerify the problem is well-posed with explicit assumptions: lambda > 0 and K_tau = K + tau I is PD (or solve restricted to Range(K)). Confirm dimensions are consistent and SPD conditions are stated correctly.\n\n## Incoming Edges (this step depends on)\n  - p10-s1 → p10-problem [challenge]: Naive explicit direct methods incur O(Nnr) memory/work\n  - p10-s3 → p10-problem [clarify]: RHS uses sparse T and Kronecker structure, same O(qr + n²r)\n  - p10-s6 → p10-problem [assert]: O(n³ + r³ + t(n²r + qr + nr²)); no explicit N-dependence\n\n## Full Problem Context\n\nThe system is: [(Z⊗K_tau)^T S S^T (Z⊗K_tau) + lambda(I_r⊗K_tau)]vec(W) = (I_r⊗K_tau)vec(B)\nwhere W in R^{n x r}, K_tau = K + tau I in R^{n x n} (PD for tau>0), Z in R^{M x r},\nS selects q observed entries from N = nM, and B = T Z.\nRegime: n, r << q << N.\n\n## Instructions\n\n1. Verify the mathematical claim in this proof step.\n2. Use only the provided local context to identify gaps, unstated assumptions, or potential errors.\n3. Suggest improvements if the claim could be tightened or clarified.\n4. Reply as a single JSON object matching the required schema."}
{"node_id": "p10-s1", "node_type": "answer", "prompt": "You are a mathematical proof verifier with expertise in numerical linear algebra, tensor decomposition, and RKHS methods.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Use only provided local context; do not perform web search.\n\n## Proof Step Under Review\n\n**Node ID**: p10-s1\n**Type**: answer\n**Claim**: Why naive direct methods fail: A is nr×nr, so dense factorization costs O(n³r³). The naive explicit route materializes (Z⊗K_tau) in ℝ^{N×nr}, costing O(Nnr), which is N-dependent and infeasible.\n\n## Verification Focus\n\nVerify the complexity claim for the naive explicit route: direct solve of an nr×nr dense system costs O(n³r³), and explicitly forming (Z⊗K_tau) costs O(Nnr) storage/operations.\n\n## Incoming Edges (this step depends on)\n  - p10-s2 → p10-s1 [reform]: CG only requires v ↦ Av, never the matrix A itself\n\n## Outgoing Edges (this step supports)\n  - p10-s1 → p10-problem [challenge]: Naive explicit direct methods incur O(Nnr) memory/work\n\n## Full Problem Context\n\nThe system is: [(Z⊗K_tau)^T S S^T (Z⊗K_tau) + lambda(I_r⊗K_tau)]vec(W) = (I_r⊗K_tau)vec(B)\nwhere W in R^{n x r}, K_tau = K + tau I in R^{n x n} (PD for tau>0), Z in R^{M x r},\nS selects q observed entries from N = nM, and B = T Z.\nRegime: n, r << q << N.\n\n## Instructions\n\n1. Verify the mathematical claim in this proof step.\n2. Use only the provided local context to identify gaps, unstated assumptions, or potential errors.\n3. Suggest improvements if the claim could be tightened or clarified.\n4. Reply as a single JSON object matching the required schema."}
{"node_id": "p10-s2", "node_type": "answer", "prompt": "You are a mathematical proof verifier with expertise in numerical linear algebra, tensor decomposition, and RKHS methods.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Use only provided local context; do not perform web search.\n\n## Proof Step Under Review\n\n**Node ID**: p10-s2\n**Type**: answer\n**Claim**: Key insight: with λ>0 and K_tau ≻ 0, PCG only needs v ↦ A v, never A explicitly. The implicit matvec costs O(n²r + qr), independent of N.\n\n## Verification Focus\n\nVerify PCG applicability under the stated assumptions (lambda>0, K_tau PD). Confirm the claimed O(n²r + qr) implicit matvec is achievable without N-sized materialization.\n\n## Incoming Edges (this step depends on)\n  - p10-s2a → p10-s2 [clarify]: Kronecker identity gives forward map; grouping by row avoids N\n  - p10-s2b → p10-s2 [clarify]: Sparse W' has s<=q nonzeros; adjoint via (Zᵀ⊗K_tau)\n  - p10-s2c → p10-s2 [clarify]: Regularization is just λ·vec(KV), O(n²r)\n  - p10-s4 → p10-s2 [reform]: Whitened surrogate motivates P = (H⊗K_tau) for faster PCG\n  - p10-s7 → p10-s2 [reference]: MATVEC subroutine implements implicit matvec\n\n## Outgoing Edges (this step supports)\n  - p10-s2 → p10-s1 [reform]: CG only requires v ↦ Av, never the matrix A itself\n\n## Full Problem Context\n\nThe system is: [(Z⊗K_tau)^T S S^T (Z⊗K_tau) + lambda(I_r⊗K_tau)]vec(W) = (I_r⊗K_tau)vec(B)\nwhere W in R^{n x r}, K_tau = K + tau I in R^{n x n} (PD for tau>0), Z in R^{M x r},\nS selects q observed entries from N = nM, and B = T Z.\nRegime: n, r << q << N.\n\n## Instructions\n\n1. Verify the mathematical claim in this proof step.\n2. Use only the provided local context to identify gaps, unstated assumptions, or potential errors.\n3. Suggest improvements if the claim could be tightened or clarified.\n4. Reply as a single JSON object matching the required schema."}
{"node_id": "p10-s2a", "node_type": "comment", "prompt": "You are a mathematical proof verifier with expertise in numerical linear algebra, tensor decomposition, and RKHS methods.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Use only provided local context; do not perform web search.\n\n## Proof Step Under Review\n\n**Node ID**: p10-s2a\n**Type**: comment\n**Claim**: Forward map at observed entries: By the Kronecker identity (A⊗B)vec(X) = vec(BXAᵀ), we get (Z⊗K)vec(V) = vec(KVZᵀ). SS'selects only q entries. Grouping by row: O(n²r + qr).\n\n## Verification Focus\n\nVerify the Kronecker identity (A⊗B)vec(X) = vec(BXAᵀ). Confirm that evaluating only at observed entries via SS' costs O(n²r + qr) by the row-grouping argument.\n\n## Incoming Edges (this step depends on)\n  - p10-s2-total → p10-s2a [assert]: Combining forward + adjoint + regularization: O(n²r + qr)\n\n## Outgoing Edges (this step supports)\n  - p10-s2a → p10-s2 [clarify]: Kronecker identity gives forward map; grouping by row avoids N\n\n## Full Problem Context\n\nThe system is: [(Z⊗K_tau)^T S S^T (Z⊗K_tau) + lambda(I_r⊗K_tau)]vec(W) = (I_r⊗K_tau)vec(B)\nwhere W in R^{n x r}, K_tau = K + tau I in R^{n x n} (PD for tau>0), Z in R^{M x r},\nS selects q observed entries from N = nM, and B = T Z.\nRegime: n, r << q << N.\n\n## Instructions\n\n1. Verify the mathematical claim in this proof step.\n2. Use only the provided local context to identify gaps, unstated assumptions, or potential errors.\n3. Suggest improvements if the claim could be tightened or clarified.\n4. Reply as a single JSON object matching the required schema."}
{"node_id": "p10-s2b", "node_type": "comment", "prompt": "You are a mathematical proof verifier with expertise in numerical linear algebra, tensor decomposition, and RKHS methods.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Use only provided local context; do not perform web search.\n\n## Proof Step Under Review\n\n**Node ID**: p10-s2b\n**Type**: comment\n**Claim**: Adjoint map from sparse result: The sparse vector w ∈ ℝ^N maps back via (Zᵀ⊗K_tau)w = vec(K_tau W'Z) where nnz(W') = s ≤ q. W'Z: O(sr), K_tau(W'Z): O(n²r). Total: O(qr + n²r).\n\n## Verification Focus\n\nVerify the adjoint computation: (Zᵀ⊗K_tau)w = vec(K_tau W'Z) where W' is sparse. Confirm O(qr + n²r) cost and check sparsity is s = nnz(W') <= q (not necessarily exactly q).\n\n## Incoming Edges (this step depends on)\n  - p10-s2-total → p10-s2b [assert]: Combining forward + adjoint + regularization: O(n²r + qr)\n\n## Outgoing Edges (this step supports)\n  - p10-s2b → p10-s2 [clarify]: Sparse W' has s<=q nonzeros; adjoint via (Zᵀ⊗K_tau)\n\n## Full Problem Context\n\nThe system is: [(Z⊗K_tau)^T S S^T (Z⊗K_tau) + lambda(I_r⊗K_tau)]vec(W) = (I_r⊗K_tau)vec(B)\nwhere W in R^{n x r}, K_tau = K + tau I in R^{n x n} (PD for tau>0), Z in R^{M x r},\nS selects q observed entries from N = nM, and B = T Z.\nRegime: n, r << q << N.\n\n## Instructions\n\n1. Verify the mathematical claim in this proof step.\n2. Use only the provided local context to identify gaps, unstated assumptions, or potential errors.\n3. Suggest improvements if the claim could be tightened or clarified.\n4. Reply as a single JSON object matching the required schema."}
{"node_id": "p10-s2c", "node_type": "comment", "prompt": "You are a mathematical proof verifier with expertise in numerical linear algebra, tensor decomposition, and RKHS methods.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Use only provided local context; do not perform web search.\n\n## Proof Step Under Review\n\n**Node ID**: p10-s2c\n**Type**: comment\n**Claim**: Regularization term: λ(Iᵣ⊗K_tau)vec(V) = λ·vec(K_tau V). Cost: O(n²r).\n\n## Verification Focus\n\nVerify the regularization term: λ(Iᵣ⊗K_tau)vec(V) = λ·vec(K_tau V). This is straightforward but confirm the Kronecker-vec identity.\n\n## Incoming Edges (this step depends on)\n  - p10-s2-total → p10-s2c [agree]: Regularization absorbed into n²r term\n\n## Outgoing Edges (this step supports)\n  - p10-s2c → p10-s2 [clarify]: Regularization is just λ·vec(KV), O(n²r)\n\n## Full Problem Context\n\nThe system is: [(Z⊗K_tau)^T S S^T (Z⊗K_tau) + lambda(I_r⊗K_tau)]vec(W) = (I_r⊗K_tau)vec(B)\nwhere W in R^{n x r}, K_tau = K + tau I in R^{n x n} (PD for tau>0), Z in R^{M x r},\nS selects q observed entries from N = nM, and B = T Z.\nRegime: n, r << q << N.\n\n## Instructions\n\n1. Verify the mathematical claim in this proof step.\n2. Use only the provided local context to identify gaps, unstated assumptions, or potential errors.\n3. Suggest improvements if the claim could be tightened or clarified.\n4. Reply as a single JSON object matching the required schema."}
{"node_id": "p10-s2-total", "node_type": "comment", "prompt": "You are a mathematical proof verifier with expertise in numerical linear algebra, tensor decomposition, and RKHS methods.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Use only provided local context; do not perform web search.\n\n## Proof Step Under Review\n\n**Node ID**: p10-s2-total\n**Type**: comment\n**Claim**: Total per matvec: O(n²r + qr). No dependence on N. This is the central result that makes PCG feasible.\n\n## Verification Focus\n\nVerify the total matvec cost O(n²r + qr) by combining steps 2a, 2b, 2c. Confirm no hidden N-dependent terms.\n\n## Incoming Edges (this step depends on)\n  - p10-s6 → p10-s2-total [reference]: Matvec cost O(n²r + qr) per iteration\n\n## Outgoing Edges (this step supports)\n  - p10-s2-total → p10-s2a [assert]: Combining forward + adjoint + regularization: O(n²r + qr)\n  - p10-s2-total → p10-s2b [assert]: Combining forward + adjoint + regularization: O(n²r + qr)\n  - p10-s2-total → p10-s2c [agree]: Regularization absorbed into n²r term\n\n## Full Problem Context\n\nThe system is: [(Z⊗K_tau)^T S S^T (Z⊗K_tau) + lambda(I_r⊗K_tau)]vec(W) = (I_r⊗K_tau)vec(B)\nwhere W in R^{n x r}, K_tau = K + tau I in R^{n x n} (PD for tau>0), Z in R^{M x r},\nS selects q observed entries from N = nM, and B = T Z.\nRegime: n, r << q << N.\n\n## Instructions\n\n1. Verify the mathematical claim in this proof step.\n2. Use only the provided local context to identify gaps, unstated assumptions, or potential errors.\n3. Suggest improvements if the claim could be tightened or clarified.\n4. Reply as a single JSON object matching the required schema."}
{"node_id": "p10-s3", "node_type": "answer", "prompt": "You are a mathematical proof verifier with expertise in numerical linear algebra, tensor decomposition, and RKHS methods.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Use only provided local context; do not perform web search.\n\n## Proof Step Under Review\n\n**Node ID**: p10-s3\n**Type**: answer\n**Claim**: Right-hand side: b = (Iᵣ⊗K_tau)vec(B) where B = TZ. T is sparse (q nonzeros), so TZ: O(qr), K_tau B: O(n²r). Total: O(qr + n²r).\n\n## Verification Focus\n\nVerify the RHS computation: B = TZ costs O(qr) when T is sparse with q nonzeros, and K_tau B costs O(n²r). Confirm dimensions: T ∈ ℝ^{n×M}, Z ∈ ℝ^{M×r}.\n\n## Outgoing Edges (this step supports)\n  - p10-s3 → p10-problem [clarify]: RHS uses sparse T and Kronecker structure, same O(qr + n²r)\n\n## Full Problem Context\n\nThe system is: [(Z⊗K_tau)^T S S^T (Z⊗K_tau) + lambda(I_r⊗K_tau)]vec(W) = (I_r⊗K_tau)vec(B)\nwhere W in R^{n x r}, K_tau = K + tau I in R^{n x n} (PD for tau>0), Z in R^{M x r},\nS selects q observed entries from N = nM, and B = T Z.\nRegime: n, r << q << N.\n\n## Instructions\n\n1. Verify the mathematical claim in this proof step.\n2. Use only the provided local context to identify gaps, unstated assumptions, or potential errors.\n3. Suggest improvements if the claim could be tightened or clarified.\n4. Reply as a single JSON object matching the required schema."}
{"node_id": "p10-s4", "node_type": "answer", "prompt": "You are a mathematical proof verifier with expertise in numerical linear algebra, tensor decomposition, and RKHS methods.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Use only provided local context; do not perform web search.\n\n## Proof Step Under Review\n\n**Node ID**: p10-s4\n**Type**: answer\n**Claim**: Preconditioner choice: after whitening by K_tau^{-1/2} and using SSᵀ ≈ cI (c=q/N), choose P = (H⊗K_tau) with H = c ZᵀZ + λIᵣ. This is a structured surrogate for A.\n\n## Verification Focus\n\nVerify the preconditioner derivation via kernel whitening and SSᵀ ≈ cI: P = (H⊗K_tau), H = c ZᵀZ + λIᵣ. Check the algebraic consistency and the SPD conditions.\n\n## Incoming Edges (this step depends on)\n  - p10-s4-hadamard → p10-s4 [clarify]: Khatri-Rao Hadamard: ZᵀZ = ∏(AᵢᵀAᵢ), O(Σnᵢr²) not O(Mr²)\n  - p10-s4-solve → p10-s4 [exemplify]: P⁻¹ = H⁻¹⊗K_tau⁻¹ via Cholesky; solve cost O(n²r + nr²)\n  - p10-s5 → p10-s4 [assert]: Spectral equivalence bounds κ(P⁻¹A), giving PCG rate O(√κ log(1/ε))\n\n## Outgoing Edges (this step supports)\n  - p10-s4 → p10-s2 [reform]: Whitened surrogate motivates P = (H⊗K_tau) for faster PCG\n\n## Full Problem Context\n\nThe system is: [(Z⊗K_tau)^T S S^T (Z⊗K_tau) + lambda(I_r⊗K_tau)]vec(W) = (I_r⊗K_tau)vec(B)\nwhere W in R^{n x r}, K_tau = K + tau I in R^{n x n} (PD for tau>0), Z in R^{M x r},\nS selects q observed entries from N = nM, and B = T Z.\nRegime: n, r << q << N.\n\n## Instructions\n\n1. Verify the mathematical claim in this proof step.\n2. Use only the provided local context to identify gaps, unstated assumptions, or potential errors.\n3. Suggest improvements if the claim could be tightened or clarified.\n4. Reply as a single JSON object matching the required schema."}
{"node_id": "p10-s4-hadamard", "node_type": "comment", "prompt": "You are a mathematical proof verifier with expertise in numerical linear algebra, tensor decomposition, and RKHS methods.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Use only provided local context; do not perform web search.\n\n## Proof Step Under Review\n\n**Node ID**: p10-s4-hadamard\n**Type**: comment\n**Claim**: Why this structure? The Khatri-Rao Hadamard property gives ZᵀZ = (A₁ᵀA₁)*(A₂ᵀA₂)*...*(Aₐᵀ Aₐ). Each Aᵢᵀ Aᵢ costs O(nᵢr²), so ZᵀZ costs O(Σᵢ nᵢr²) — vastly cheaper than O(Mr²).\n\n## Verification Focus\n\nVerify the Khatri-Rao Hadamard property: ZᵀZ = ∏ᵢ(AᵢᵀAᵢ) where ∏ is elementwise product. Confirm the O(Σᵢ nᵢr²) cost. This is a key identity in tensor decomposition — find math.SE references.\n\n## Outgoing Edges (this step supports)\n  - p10-s4-hadamard → p10-s4 [clarify]: Khatri-Rao Hadamard: ZᵀZ = ∏(AᵢᵀAᵢ), O(Σnᵢr²) not O(Mr²)\n\n## Full Problem Context\n\nThe system is: [(Z⊗K_tau)^T S S^T (Z⊗K_tau) + lambda(I_r⊗K_tau)]vec(W) = (I_r⊗K_tau)vec(B)\nwhere W in R^{n x r}, K_tau = K + tau I in R^{n x n} (PD for tau>0), Z in R^{M x r},\nS selects q observed entries from N = nM, and B = T Z.\nRegime: n, r << q << N.\n\n## Instructions\n\n1. Verify the mathematical claim in this proof step.\n2. Use only the provided local context to identify gaps, unstated assumptions, or potential errors.\n3. Suggest improvements if the claim could be tightened or clarified.\n4. Reply as a single JSON object matching the required schema."}
{"node_id": "p10-s4-solve", "node_type": "comment", "prompt": "You are a mathematical proof verifier with expertise in numerical linear algebra, tensor decomposition, and RKHS methods.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Use only provided local context; do not perform web search.\n\n## Proof Step Under Review\n\n**Node ID**: p10-s4-solve\n**Type**: comment\n**Claim**: Preconditioner solve: P⁻¹ = H⁻¹⊗K_tau⁻¹. Precompute Cholesky of K_tau (O(n³)) and H (O(r³)). Each application solves K_tau Y Hᵀ = Z' via triangular substitution in O(n²r + nr²).\n\n## Verification Focus\n\nVerify the Kronecker inverse: (H⊗K_tau)⁻¹ = H⁻¹⊗K_tau⁻¹. Confirm this requires K_tau and H invertible (PD). Verify Cholesky-based apply cost O(n²r + nr²).\n\n## Incoming Edges (this step depends on)\n  - p10-s6 → p10-s4-solve [reference]: Preconditioner solve O(n²r + nr²) per iteration\n  - p10-s7 → p10-s4-solve [reference]: PRECOND_SOLVE subroutine implements Kronecker inverse\n\n## Outgoing Edges (this step supports)\n  - p10-s4-solve → p10-s4 [exemplify]: P⁻¹ = H⁻¹⊗K_tau⁻¹ via Cholesky; solve cost O(n²r + nr²)\n\n## Full Problem Context\n\nThe system is: [(Z⊗K_tau)^T S S^T (Z⊗K_tau) + lambda(I_r⊗K_tau)]vec(W) = (I_r⊗K_tau)vec(B)\nwhere W in R^{n x r}, K_tau = K + tau I in R^{n x n} (PD for tau>0), Z in R^{M x r},\nS selects q observed entries from N = nM, and B = T Z.\nRegime: n, r << q << N.\n\n## Instructions\n\n1. Verify the mathematical claim in this proof step.\n2. Use only the provided local context to identify gaps, unstated assumptions, or potential errors.\n3. Suggest improvements if the claim could be tightened or clarified.\n4. Reply as a single JSON object matching the required schema."}
{"node_id": "p10-s5", "node_type": "answer", "prompt": "You are a mathematical proof verifier with expertise in numerical linear algebra, tensor decomposition, and RKHS methods.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Use only provided local context; do not perform web search.\n\n## Proof Step Under Review\n\n**Node ID**: p10-s5\n**Type**: answer\n**Claim**: Convergence: PCG has t = O(√κ log(1/ε)) with κ = cond(P^{-1/2} A P^{-1/2}). Sufficient conditions: δ = O(√(n log n / q)) via Tropp 2011 Thm 1.6 matrix concentration on SS'-cI. Requires q >> n log n.\n\n## Verification Focus\n\nVerify the standard PCG convergence bound t = O(√κ·log(1/ε)) and the spectral-equivalence implication: if (1-δ)P ≼ A ≼ (1+δ)P, then κ(P⁻¹A) ≤ (1+δ)/(1-δ). Check assumptions needed for this.\n\n## Incoming Edges (this step depends on)\n  - p10-s6 → p10-s5 [reference]: Iteration count from standard PCG bound and κ(P⁻¹A)\n\n## Outgoing Edges (this step supports)\n  - p10-s5 → p10-s4 [assert]: Spectral equivalence bounds κ(P⁻¹A), giving PCG rate O(√κ log(1/ε))\n\n## Full Problem Context\n\nThe system is: [(Z⊗K_tau)^T S S^T (Z⊗K_tau) + lambda(I_r⊗K_tau)]vec(W) = (I_r⊗K_tau)vec(B)\nwhere W in R^{n x r}, K_tau = K + tau I in R^{n x n} (PD for tau>0), Z in R^{M x r},\nS selects q observed entries from N = nM, and B = T Z.\nRegime: n, r << q << N.\n\n## Instructions\n\n1. Verify the mathematical claim in this proof step.\n2. Use only the provided local context to identify gaps, unstated assumptions, or potential errors.\n3. Suggest improvements if the claim could be tightened or clarified.\n4. Reply as a single JSON object matching the required schema."}
{"node_id": "p10-s6", "node_type": "answer", "prompt": "You are a mathematical proof verifier with expertise in numerical linear algebra, tensor decomposition, and RKHS methods.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Use only provided local context; do not perform web search.\n\n## Proof Step Under Review\n\n**Node ID**: p10-s6\n**Type**: answer\n**Claim**: Complexity summary: total per mode-k subproblem is O(n³ + r³ + t(n²r + qr + nr²)). Compare direct O(n³r³ + Nnr). PCG removes N-dependence. Regime caveat: when n³ Cholesky dominates, consider Nystrom/iterative alternatives.\n\n## Verification Focus\n\nVerify the final complexity: O(n³ + r³ + t(n²r + qr + nr²)) (or simplified O(n³ + t(n²r + qr)) when n≥r) vs direct O(n³r³ + Nnr). Confirm the reduction holds when n, r ≪ q ≪ N.\n\n## Incoming Edges (this step depends on)\n  - p10-s7 → p10-s6 [exemplify]: Pseudocode instantiates the complexity analysis\n\n## Outgoing Edges (this step supports)\n  - p10-s6 → p10-problem [assert]: O(n³ + r³ + t(n²r + qr + nr²)); no explicit N-dependence\n  - p10-s6 → p10-s2-total [reference]: Matvec cost O(n²r + qr) per iteration\n  - p10-s6 → p10-s4-solve [reference]: Preconditioner solve O(n²r + nr²) per iteration\n  - p10-s6 → p10-s5 [reference]: Iteration count from standard PCG bound and κ(P⁻¹A)\n\n## Full Problem Context\n\nThe system is: [(Z⊗K_tau)^T S S^T (Z⊗K_tau) + lambda(I_r⊗K_tau)]vec(W) = (I_r⊗K_tau)vec(B)\nwhere W in R^{n x r}, K_tau = K + tau I in R^{n x n} (PD for tau>0), Z in R^{M x r},\nS selects q observed entries from N = nM, and B = T Z.\nRegime: n, r << q << N.\n\n## Instructions\n\n1. Verify the mathematical claim in this proof step.\n2. Use only the provided local context to identify gaps, unstated assumptions, or potential errors.\n3. Suggest improvements if the claim could be tightened or clarified.\n4. Reply as a single JSON object matching the required schema."}
{"node_id": "p10-s7", "node_type": "answer", "prompt": "You are a mathematical proof verifier with expertise in numerical linear algebra, tensor decomposition, and RKHS methods.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Use only provided local context; do not perform web search.\n\n## Proof Step Under Review\n\n**Node ID**: p10-s7\n**Type**: answer\n**Claim**: Algorithm: SETUP builds K_tau, H, and RHS; PCG then applies implicit MATVEC on observed entries and PRECOND_SOLVE via Kronecker factors each iteration.\n\n## Verification Focus\n\nVerify the mathematical claim.\n\n## Outgoing Edges (this step supports)\n  - p10-s7 → p10-s6 [exemplify]: Pseudocode instantiates the complexity analysis\n  - p10-s7 → p10-s2 [reference]: MATVEC subroutine implements implicit matvec\n  - p10-s7 → p10-s4-solve [reference]: PRECOND_SOLVE subroutine implements Kronecker inverse\n\n## Full Problem Context\n\nThe system is: [(Z⊗K_tau)^T S S^T (Z⊗K_tau) + lambda(I_r⊗K_tau)]vec(W) = (I_r⊗K_tau)vec(B)\nwhere W in R^{n x r}, K_tau = K + tau I in R^{n x n} (PD for tau>0), Z in R^{M x r},\nS selects q observed entries from N = nM, and B = T Z.\nRegime: n, r << q << N.\n\n## Instructions\n\n1. Verify the mathematical claim in this proof step.\n2. Use only the provided local context to identify gaps, unstated assumptions, or potential errors.\n3. Suggest improvements if the claim could be tightened or clarified.\n4. Reply as a single JSON object matching the required schema."}
{"node_id": "p10-synthesis", "node_type": "synthesis", "prompt": "You are a mathematical proof verifier reviewing a complete proof.\n\n## Task\n\nVerify one step of a proof that PCG solves RKHS-constrained tensor CP decomposition without O(N) computation. Assess completeness, correctness, and suggest improvements.\n\n## Proof\n\n# Problem 10: RKHS-Constrained Tensor CP via Preconditioned Conjugate Gradient\n\n## Problem Statement\n\nGiven the mode-k subproblem of RKHS-constrained CP decomposition with\nmissing data, solve\n\n    [(Z x K)^T D (Z x K) + lambda (I_r x K)] vec(W) = (I_r x K) vec(B),\n\nwhere D = S S^T is the observation projector (q observed entries out of\nN = nM), B = T Z, and n, r << q << N.\n\n## Assumptions Used (explicit)\n\n1. lambda > 0.\n2. For standard PCG and Cholesky-based preconditioning, use a PD kernel\n   K_tau = K + tau I_n with tau > 0 (or assume K is already PD).\n3. S is a selection operator, so D is diagonal/projector and sparse by index list.\n\nThen the solved system is\n\n    A_tau x = b_tau,\n    A_tau = (Z x K_tau)^T D (Z x K_tau) + lambda (I_r x K_tau),\n    x = vec(W),\n    b_tau = (I_r x K_tau) vec(B).\n\nUnder these assumptions A_tau is SPD, so PCG applies.\n\n## Solution\n\n### 1. Why naive direct methods fail\n\nA_tau is an (nr) x (nr) system. Dense direct factorization costs\n$O((nr)^3)$ = $O(n^3 r^3)$.\n\nA naive explicit route also materializes Phi = Z x K_tau in R^{N x nr},\nwhich costs $O(N n r)$ memory/work before factorization. This is the\n$N$-dependent bottleneck we avoid with matrix-free PCG.\n\n### 2. Implicit matrix-vector product in $O(n^2 r + q r)$\n\nCG needs only y = A_tau x, not A_tau explicitly.\n\nGiven x = vec(V), $V \\in R$^{n x r}:\n\n1. U = K_tau V. Cost $O(n^2 r)$.\n2. Forward sampled action (only observed entries):\n\n       (Z x K_tau) vec(V) = vec(K_tau V Z^T).\n\n   For each observed coordinate (i_l, j_l),\n\n       u_l = <U[i_l, :], Z[j_l, :]>.\n\n   Total $O(q r)$.\n3. Form sparse W' in R^{n x M} from u_l. Let s = nnz(W') <= q.\n4. Adjoint sampled action:\n\n       (Z^T x K_tau) vec(W') = vec(K_tau W' Z).\n\n   Compute W' Z in $O(s r)$ <= $O(q r)$, then left-multiply by K_tau in $O(n^2 r)$.\n5. Add regularization term lambda vec(K_tau V), cost $O(n^2 r)$.\n\nTotal per matvec:\n\n    O(n^2 r + q r),\n\nwith no $O(N)$ term.\n\n### 3. Right-hand side\n\nB = T Z with T sparse (q nonzeros):\n\n1. T Z: $O(q r)$\n2. K_tau B: $O(n^2 r)$\n\nSo b_tau = (I_r x K_tau) vec(B) is formed in $O(q r + n^2 r)$.\n\n### 4. Preconditioner that matches the corrected algebra\n\nUse D = S S^T and whiten by K_tau^{-1/2}:\n\n    x = (I_r x K_tau^{-1/2}) y.\n\nThen\n\n    Ahat = (I_r x K_tau^{-1/2}) A_tau (I_r x K_tau^{-1/2})\n         = (Z x K_tau^{1/2})^T D (Z x K_tau^{1/2}) + lambda I.\n\nIf sampling is roughly uniform, D ~ c I with c = q/N. Then\n\n    Ahat ~ c (Z^T Z x K_tau) + lambda I.\n\nChoose Kron preconditioner in whitened coordinates:\n\n    Phat = (c Z^T Z + lambda I_r) x I_n.\n\nMapping back gives\n\n    P = (c Z^T Z + lambda I_r) x K_tau = H x K_tau,\n    H = c Z^T Z + lambda I_r.\n\nThis is the missing justification for using H x K_tau (instead of claiming\nit is the exact D = I system).\n\nKhatri-Rao identity still gives efficient Gram formation:\n\n    Z^T Z = Hadamard_i (A_i^T A_i),\n\ncost $O(sum_i n_i r^2)$.\n\nPreconditioner apply:\n\n    P^{-1} = H^{-1} x K_tau^{-1},\n\nimplemented by solving K_tau Y H^T = Z' after reshape.\nPer application cost is $O(n^2 r + n r^2)$ (often simplified to $O(n^2 r)$\nwhen n >> r).\n\n### 5. Convergence (tightened)\n\nFor SPD A_tau and SPD P, standard PCG gives\n\n    ||e_t||_{A_tau} <= 2 ((sqrt(kappa)-1)/(sqrt(kappa)+1))^t ||e_0||_{A_tau},\n\nwith kappa = cond(P^{-1/2} A_tau P^{-1/2}), so\n\n    t = O(sqrt(kappa) log(1/eps)).\n\nTo claim \"fast\" convergence, add a spectral-equivalence hypothesis, e.g.\n\n    (1-delta) P <= A_tau <= (1+delta) P, 0 < delta < 1,\n\nwhich implies\n\n    kappa(P^{-1} A_tau) <= (1+delta)/(1-delta).\n\nHence t is logarithmic in 1/eps with a modest sqrt(kappa) factor when\ndelta is bounded away from 1. (No unsupported closed-form t = $O(r sqrt(n/q))$\nclaim is needed.)\n\n**Sufficient conditions for bounded delta.** The spectral equivalence\n(1-delta)P <= A_tau <= (1+delta)P holds with delta bounded away from 1 when\nthe sampling pattern satisfies a restricted isometry-type condition:\nthe restricted isometry holds for the column space of Z ⊗ K_tau^{1/2},\ni.e. (Z ⊗ K_tau^{1/2})^T (D - cI) (Z ⊗ K_tau^{1/2}) is small in\noperator norm relative to lambda. Under standard leverage/coherence\nassumptions and sufficient sampling scaling with model dimension,\nconcentration yields delta bounded away from 1 with high probability. Under this regime, kappa = $O(1)$ and PCG converges in\n$O(log(1/eps))$ iterations.\n\n### 6. Complexity summary\n\nSetup per ALS outer step:\n\n1. Cholesky(K_tau): $O(n^3)$\n2. Z^T Z via Hadamard Grams: $O(sum_i n_i r^2)$\n3. Cholesky(H): $O(r^3)$\n4. RHS: $O(q r + n^2 r)$\n\nPer PCG iteration:\n\n1. Matvec: $O(n^2 r + q r)$\n2. Preconditioner apply: $O(n^2 r + n r^2)$\n\nTotal:\n\n    O(n^3 + r^3 + sum_i n_i r^2 + q r + n^2 r\n      + t (n^2 r + q r + n r^2)).\n\nIn the common regime n >= r, this simplifies to\n\n    O(n^3 + t (n^2 r + q r)),\n\nwith dependence on q (observed entries) rather than N (all entries).\n\n**Regime caveat.** When n is large enough that the $O(n^3)$ Cholesky setup\ndominates (i.e., n^3 > t(n^2 r + q r)), the per-ALS-step cost is effectively\n$O(n^3)$. In this regime, low-rank kernel approximations (e.g., Nystrom\napproximation with rank p << n, reducing the kernel factorization to $O(n p^2)$)\nor iterative inner solves (conjugate gradient on K_tau y = z, cost $O(n^2)$\nper inner iteration) can replace the exact Cholesky, reducing the setup to\n$O(n p^2 + t(n p r + q r))$. This is a well-known practical optimization\n(see Rudi-Calandriello-Rosasco 2017) and is compatible with the PCG framework\nas presented.\n\n### 7. Algorithm\n\n```text\nSETUP:\n  K_tau = K + tau * I_n                    # tau > 0 if K is only PSD\n  L_K = cholesky(K_tau)                    # O(n^3)\n  G = hadamard_product(A_i^T A_i for i != k)  # O(sum_i n_i r^2)\n  c = q / N\n  H = c * G + lambda * I_r\n  L_H = cholesky(H)                        # O(r^3)\n  B = sparse_mttkrp(T, Z)                  # O(qr)\n  b = vec(K_tau @ B)                       # O(n^2 r)\n\nPCG(A_tau x = b, preconditioner P = H x K_tau):\n  x0 = 0\n  r0 = b\n  z0 = precond_solve(L_K, L_H, r0)         # O(n^2 r + n r^2)\n  p0 = z0\n  repeat until convergence:\n    w = matvec_A_tau(p)                    # O(n^2 r + q r)\n    alpha = (r^T z) / (p^T w)\n    x = x + alpha * p\n    r_new = r - alpha * w\n    if ||r_new|| <= eps * ||b||: break\n    z_new = precond_solve(L_K, L_H, r_new)\n    beta = (r_new^T z_new) / (r^T z)\n    p = z_new + beta * p\n    r, z = r_new, z_new\n  W = reshape(x, n, r)\n\nmatvec_A_tau(v):\n  V = reshape(v, n, r)\n  U = K_tau @ V\n  for each observed (i_l, j_l):\n    u_l = dot(U[i_l, :], Z[j_l, :])\n  Wprime = sparse(n, M, entries u_l)\n  Y = K_tau @ (Wprime @ Z) + lambda * (K_tau @ V)\n  return vec(Y)\n\nprecond_solve(L_K, L_H, z):\n  Zp = reshape(z, n, r)\n  solve K_tau Y H^T = Zp using triangular solves with L_K, L_H\n  return vec(Y)\n```\n\n## Key References from futon6 corpus\n\n- PlanetMath: conjugate gradient algorithm; method of conjugate gradients\n- PlanetMath: Kronecker product; positive definite matrices\n- PlanetMath: properties of tensor product\n- physics.SE #27466: iterative solvers for large systems in physics\n- physics.SE #27556: preconditioning for elliptic PDEs\n\n## 8. Gap Ledger (Requirement Compliant)\n\nStatus labels follow `proved | partial | open | false | numerically verified`.\n\n| ID | Item | Status | Why | Evidence artifact |\n|---|---|---|---|---|\n| P10-G1 | Node-level external verifier run integrity | partial | Historical run failed due unsupported model configuration; remediation rerun is required. | `data/first-proof/problem10-codex-results.jsonl` |\n| P10-G2 | Convergence-rate strength under sampling assumptions | partial | The fast-rate claim is conditional on spectral equivalence and sampling regularity assumptions. | Section 5 (`(1-delta)P <= A_tau <= (1+delta)P`) |\n| P10-G3 | Explicit cycle record and named-gap discipline | proved | This section and Section 9 provide named gaps and cycle metadata. | This file (Sections 8-9) |\n\nInterpretation:\n- The mathematical writeup is **conditionally closed** under stated assumptions.\n- Remaining work is primarily process-validation (`P10-G1`) and not a discovered mathematical contradiction.\n\n## 9. Cycle Record (2026-02-13 Remediation)\n\n```text\ncycle_id: P10-remediation-2026-02-13\nproblem_id: P10\nblocker_id: P10-G1\nhypothesis: Rerunning node-level verifier with a supported model restores valid machine-readable verification artifacts.\nstop_conditions: either (a) results regenerate with parseable JSON outputs, or (b) runtime/tooling failure is explicitly recorded with reproducible stderr evidence.\nexecution_artifact_paths:\n  - data/first-proof/problem10-codex-prompts.jsonl\n  - data/first-proof/problem10-codex-results.jsonl\n  - /tmp/p10-codex-rerun.log\nvalidation_artifact_paths:\n  - data/first-proof/problem10-codex-results.jsonl\nresult_status: partial\nstatus_change: P10-G1 moved from false to partial, pending successful supported-model rerun completion.\nfailure_point: if unresolved, the failure is operational/tooling (model/runtime), not a theorem-level contradiction in Sections 1-7.\nnext_blocker: P10-G1\ncommit_hash: pending\n```\n\n\n## Wiring Diagram Summary\n\nNodes: 14, Edges: 20\nEdge types: {\"challenge\": 1, \"reform\": 2, \"clarify\": 5, \"assert\": 4, \"agree\": 1, \"exemplify\": 2, \"reference\": 5}\n\n## Instructions\n\n1. Is the proof complete, and does the final complexity claim follow?\n2. Are SPD assumptions, preconditioner derivation, and convergence assumptions explicit?\n3. Which steps are still weakest, and how can they be tightened?\n4. Use only the provided local proof text and wiring context (no web search).\n4. Reply as a single JSON object matching the required schema. Use node_id='p10-synthesis' for the synthesis."}
