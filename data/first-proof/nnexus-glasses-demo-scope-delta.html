<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>NNexus Glasses Scope Delta Demo</title>
<style>
* { box-sizing: border-box; }
body { margin: 0; font-family: Georgia, 'Times New Roman', serif; background: #f7f7f4; color: #1f2937; }
.wrap { max-width: 1200px; margin: 0 auto; padding: 24px 16px 56px; }
h1 { margin: 0 0 4px; font-size: 1.45rem; }
.sub { color: #6b7280; font-size: 0.9rem; margin-bottom: 18px; }
.note { background: #e8eefc; border: 1px solid #bfdbfe; padding: 12px 14px; border-radius: 8px; font-family: system-ui, sans-serif; font-size: 0.86rem; line-height: 1.45; margin-bottom: 16px; }
.stats { display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 10px; margin-bottom: 16px; }
.stat { background: #fff; border: 1px solid #d1d5db; border-radius: 8px; padding: 10px 12px; }
.stat .k { font: 700 0.72rem/1 system-ui, sans-serif; text-transform: uppercase; letter-spacing: .06em; color: #64748b; }
.stat .v { font: 700 1.25rem/1.15 system-ui, sans-serif; color: #111827; margin-top: 4px; }
.grid { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
.card { background: #fff; border: 1px solid #d1d5db; border-radius: 10px; padding: 14px 14px 16px; }
.card h2 { margin: 0 0 8px; font-size: 1rem; font-family: system-ui, sans-serif; }
.pill { display: inline-block; font: 700 0.65rem/1 system-ui, sans-serif; text-transform: uppercase; letter-spacing: .05em; border-radius: 999px; padding: 4px 8px; margin-right: 6px; }
.pill.legacy { background: #dbeafe; color: #1d4ed8; border: 1px solid #93c5fd; }
.pill.common { background: #dcfce7; color: #166534; border: 1px solid #86efac; }
.pill.added { background: #ffedd5; color: #9a3412; border: 1px solid #fdba74; }
.textbox { border: 1px solid #e5e7eb; border-radius: 8px; background: #fcfcfb; padding: 12px; line-height: 1.5; max-height: 420px; overflow: auto; white-space: pre-wrap; }
.scope-legacy { background: rgba(59,130,246,.13); border-bottom: 2px solid #3b82f6; border-radius: 3px; padding: 0 2px; }
.scope-common { background: rgba(16,185,129,.14); border-bottom: 2px solid #10b981; border-radius: 3px; padding: 0 2px; }
.scope-added { background: rgba(249,115,22,.14); border-bottom: 2px solid #f97316; border-radius: 3px; padding: 0 2px; }
.table { width: 100%; border-collapse: collapse; font-family: system-ui, sans-serif; font-size: 0.82rem; }
.table th, .table td { border-bottom: 1px solid #e5e7eb; padding: 7px 6px; text-align: left; vertical-align: top; }
.table th { color: #475569; font-weight: 700; font-size: 0.72rem; text-transform: uppercase; letter-spacing: .04em; }
.table code { background: #f1f5f9; padding: 1px 4px; border-radius: 4px; }
.section { margin-top: 16px; }
.mini { font-family: system-ui, sans-serif; font-size: 0.82rem; color: #475569; }
pre { margin: 8px 0 0; background: #0f172a; color: #e2e8f0; border-radius: 8px; padding: 10px 12px; overflow: auto; font-size: 0.78rem; }
@media (max-width: 980px) {
  .grid { grid-template-columns: 1fr; }
  .stats { grid-template-columns: 1fr 1fr; }
}
</style>
</head>
<body>
<div class="wrap">
  <h1>NNexus Glasses Scope Delta Demo</h1>
  <p class="sub">New file, original demo unchanged: <code>data/first-proof/nnexus-glasses-demo.html</code></p>

  <div class="note">
    This page compares scope treatment on the same thread (<a href="https://math.stackexchange.com/questions/633512" target="_blank">math.SE #633512</a>):
    legacy scopes from the original wiring snapshot vs new scopes from the updated detector (metatheory typing + extra scope forms).
  </div>

  <div class="stats" id="stats"></div>

  <div class="grid">
    <div class="card">
      <h2>Legacy Scope Overlay <span class="pill legacy">Legacy</span></h2>
      <div class="mini">Scopes in original wiring: <code>bind/let</code>, <code>quant/universal</code>, <code>constrain/where</code></div>
      <div class="textbox" id="legacy-text"></div>
    </div>

    <div class="card">
      <h2>New Scope Overlay <span class="pill common">Common</span><span class="pill added">Added</span></h2>
      <div class="mini">New detector adds scope forms like <code>constrain/such-that</code> and symbolic binders/environments where present.</div>
      <div class="textbox" id="new-text"></div>
    </div>
  </div>

  <div class="section card">
    <h2>Added Scopes In This Thread</h2>
    <table class="table" id="added-table">
      <thead><tr><th>Type</th><th>Match</th><th>Pos</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="section card">
    <h2>Type Count Delta</h2>
    <table class="table" id="type-table">
      <thead><tr><th>Type</th><th>Legacy</th><th>New</th><th>Delta</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="section card">
    <h2>Paper TeX Scope Case (math.CT)</h2>
    <div class="mini" id="paper-meta"></div>
    <pre id="paper-snippet"></pre>
  </div>
</div>

<script>
const DATA = {"thread": {"id": 633512, "url": "https://math.stackexchange.com/questions/633512", "title": "What is the definition of a commutative diagram?", "question_text": "Reading in ACC (the joy of cats) I was quite surprised to meet a real definition of diagram . This word had been used exactly $27$ times allready (just believe me) and the question ‘what is it?’ had not reached my thinking whatsoever. Okay, good to have a definition (11.1(1) see under), but it triggered me to expect a definition of commutative diagram as well. Alas, it was not there. In my intuition I think of a diagram having a poset as scheme, but I don’t trust that intuition enough to take this for granted. So I am asking you here: What is the definition of a commutative diagram? Thanks in advance 11.1 (1) A diagram in a category $\\mathcal{A}$ is a functor $D:\\mathcal{I}\\rightarrow\\mathcal{A}$ with codomain $\\mathcal{A}$. The domain, $\\mathcal{I}$, is called the scheme of the diagram.", "answer_id": "a-633527", "answer_text": "Let $\\Gamma=(V,E,s,t)$ be a directed graph ($V$ = vertices, $E$ = edges, $s$ = source, $t$ = target). Let $\\mathcal{C}$ be a category. A diagram of shape $\\Gamma$ in $\\mathcal{C}$ is a family of objects $X(v) \\in \\mathcal{C}$ for every vertex $v \\in V$ and morphisms $X(e)$ in $\\mathcal{C}$ for every edge $e \\in E$ such that $s(X(e))=X(s(e))$ and $t(X(e))=X(t(e))$ for all $e \\in E$. Thus, every edge $e : v \\to w$ is mapped to a morphism $X(e) : X(v) \\to X(w)$. For a path $\\gamma$ in $\\Gamma$ we define a morphism $X(\\gamma)$ in $\\mathcal{C}$ by induction: If $\\gamma$ is the empty path at a vertex $v$, let $X(\\gamma):=\\mathrm{id}_{X(v)}$. If $\\gamma = \\beta \\circ e$ for a shorter path $\\beta$ and an edge $e$, define $X(\\gamma) := X(\\beta) \\circ X(e)$. The diagram $X$ is called commutative if for all vertices $v,w \\in V$ and all two paths $\\gamma,\\gamma'$ in $\\Gamma$ from $v$ to $w$ we have $X(\\gamma)=X(\\gamma')$. Convince yourself that this coincides with the usual definition for simple examples such as $$\\Gamma = \\begin{array}{c} \\bullet & \\rightarrow & \\bullet \\\\ \\downarrow && \\downarrow \\\\ \\bullet & \\rightarrow & \\bullet \\end{array}$$ There is a close connection between diagrams and functors. If $\\mathsf{Path}(\\Gamma)$ denotes the path category, then functors $\\mathsf{Path}(\\Gamma) \\to \\mathcal{C}$ correspond to diagrams of shape $\\Gamma$ in $\\mathcal{C}$. These in turn correspond to homomorphisms of directed graphs $\\Gamma \\to U(\\mathcal{C})$, where $U(-)$ is the forgetful functor from categories to directed graphs. If one even regards arbitrary functors (with small domain category) as diagrams, then we may use the same definition of commutativity as above: Every two chains of morphisms between two given objects are mapped to the same morphism. Sometimes one only demands the commutativity condition for certain paths. For example, when dealing with sheaves or simplicial sets, usually a diagram of the shape $$\\begin{array}{c} \\bullet & \\rightrightarrows & \\bullet \\\\ \\downarrow && \\downarrow \\\\ \\bullet & \\rightrightarrows & \\bullet \\end{array}$$ is called commutative if the two squares which consist of the two upper resp. lower horizontal morphisms are commutative. PS: I have just found that these definitions can also be found in Grothendieck’s Tohoku paper."}, "legacy_scopes": [{"hx/id": "a-633527:scope-000", "hx/role": "component", "hx/type": "bind/let", "hx/content": {"match": "Let $\\Gamma=(V,E,s,t)$ be a directed graph (", "position": 0}, "hx/ends": [{"role": "symbol", "latex": "\\Gamma=(V,E,s,t)"}, {"role": "description", "text": "a directed graph"}, {"role": "parameters", "text": "V = vertices, E = edges, s = source, t = target"}]}, {"hx/id": "a-633527:scope-001", "hx/role": "component", "hx/type": "bind/let", "hx/content": {"match": "Let $\\mathcal{C}$ be a category", "position": 102}, "hx/ends": [{"role": "symbol", "latex": "\\mathcal{C}"}, {"role": "description", "text": "a category"}]}, {"hx/id": "a-633527:scope-002", "hx/role": "component", "hx/type": "quant/universal", "hx/content": {"match": "for all $e \\in E$", "position": 366}, "hx/ends": [{"role": "variable", "latex": "e"}, {"role": "domain", "latex": "E", "text": "edges of the graph"}]}, {"hx/id": "a-633527:scope-003", "hx/role": "component", "hx/type": "constrain/where", "hx/content": {"match": "where $U(-)$ is the forgetful functor from categories to directed graphs", "position": 1469}, "hx/ends": [{"role": "symbol", "latex": "U(-)"}, {"role": "description", "text": "the forgetful functor from categories to directed graphs"}]}], "new_scopes": [{"hx/id": "a-633527:scope-000", "hx/role": "component", "hx/type": "bind/let", "hx/parent": null, "hx/ends": [{"role": "entity", "ident": "a-633527"}, {"role": "symbol", "latex": "\\Gamma=(V,E,s,t)"}, {"role": "type", "text": "a directed graph ("}], "hx/content": {"match": "Let $\\Gamma=(V,E,s,t)$ be a directed graph (", "position": 0}, "hx/labels": ["scope", "let-binding"], "delta_status": "common"}, {"hx/id": "a-633527:scope-001", "hx/role": "component", "hx/type": "bind/let", "hx/parent": null, "hx/ends": [{"role": "entity", "ident": "a-633527"}, {"role": "symbol", "latex": "\\mathcal{C}"}, {"role": "type", "text": "a category"}], "hx/content": {"match": "Let $\\mathcal{C}$ be a category", "position": 102}, "hx/labels": ["scope", "let-binding"], "delta_status": "common"}, {"hx/id": "a-633527:scope-002", "hx/role": "component", "hx/type": "quant/universal", "hx/parent": null, "hx/ends": [{"role": "entity", "ident": "a-633527"}, {"role": "quantifier", "text": "all"}, {"role": "symbol", "latex": "e \\in E"}], "hx/content": {"match": "for all $e \\in E$", "position": 366}, "hx/labels": ["scope", "for-any"], "delta_status": "common"}, {"hx/id": "a-633527:scope-003", "hx/role": "component", "hx/type": "constrain/where", "hx/parent": null, "hx/ends": [{"role": "entity", "ident": "a-633527"}, {"role": "symbol", "latex": "U(-)"}, {"role": "description", "text": "the forgetful functor from categories to directed graphs"}], "hx/content": {"match": "where $U(-)$ is the forgetful functor from categories to directed graphs", "position": 1469}, "hx/labels": ["scope", "where-binding"], "delta_status": "common"}, {"hx/id": "a-633527:scope-004", "hx/role": "component", "hx/type": "constrain/such-that", "hx/parent": null, "hx/ends": [{"role": "entity", "ident": "a-633527"}, {"role": "membership", "latex": "X(v) \\in \\mathcal{C}"}], "hx/content": {"match": "$X(v) \\in \\mathcal{C}$", "position": 203}, "hx/labels": ["scope", "set-notation"], "delta_status": "added"}, {"hx/id": "a-633527:scope-005", "hx/role": "component", "hx/type": "constrain/such-that", "hx/parent": null, "hx/ends": [{"role": "entity", "ident": "a-633527"}, {"role": "membership", "latex": "v \\in V"}], "hx/content": {"match": "$v \\in V$", "position": 243}, "hx/labels": ["scope", "set-notation"], "delta_status": "added"}, {"hx/id": "a-633527:scope-006", "hx/role": "component", "hx/type": "constrain/such-that", "hx/parent": null, "hx/ends": [{"role": "entity", "ident": "a-633527"}, {"role": "membership", "latex": "e \\in E"}], "hx/content": {"match": "$e \\in E$", "position": 306}, "hx/labels": ["scope", "set-notation"], "delta_status": "added"}, {"hx/id": "a-633527:scope-007", "hx/role": "component", "hx/type": "constrain/such-that", "hx/parent": null, "hx/ends": [{"role": "entity", "ident": "a-633527"}, {"role": "membership", "latex": "e \\in E"}], "hx/content": {"match": "$e \\in E$", "position": 374}, "hx/labels": ["scope", "set-notation"], "delta_status": "added"}, {"hx/id": "a-633527:scope-008", "hx/role": "component", "hx/type": "constrain/such-that", "hx/parent": null, "hx/ends": [{"role": "entity", "ident": "a-633527"}, {"role": "membership", "latex": "v,w \\in V"}], "hx/content": {"match": "$v,w \\in V$", "position": 817}, "hx/labels": ["scope", "set-notation"], "delta_status": "added"}], "added_scopes": [{"hx/id": "a-633527:scope-004", "hx/role": "component", "hx/type": "constrain/such-that", "hx/parent": null, "hx/ends": [{"role": "entity", "ident": "a-633527"}, {"role": "membership", "latex": "X(v) \\in \\mathcal{C}"}], "hx/content": {"match": "$X(v) \\in \\mathcal{C}$", "position": 203}, "hx/labels": ["scope", "set-notation"], "delta_status": "added"}, {"hx/id": "a-633527:scope-005", "hx/role": "component", "hx/type": "constrain/such-that", "hx/parent": null, "hx/ends": [{"role": "entity", "ident": "a-633527"}, {"role": "membership", "latex": "v \\in V"}], "hx/content": {"match": "$v \\in V$", "position": 243}, "hx/labels": ["scope", "set-notation"], "delta_status": "added"}, {"hx/id": "a-633527:scope-006", "hx/role": "component", "hx/type": "constrain/such-that", "hx/parent": null, "hx/ends": [{"role": "entity", "ident": "a-633527"}, {"role": "membership", "latex": "e \\in E"}], "hx/content": {"match": "$e \\in E$", "position": 306}, "hx/labels": ["scope", "set-notation"], "delta_status": "added"}, {"hx/id": "a-633527:scope-007", "hx/role": "component", "hx/type": "constrain/such-that", "hx/parent": null, "hx/ends": [{"role": "entity", "ident": "a-633527"}, {"role": "membership", "latex": "e \\in E"}], "hx/content": {"match": "$e \\in E$", "position": 374}, "hx/labels": ["scope", "set-notation"], "delta_status": "added"}, {"hx/id": "a-633527:scope-008", "hx/role": "component", "hx/type": "constrain/such-that", "hx/parent": null, "hx/ends": [{"role": "entity", "ident": "a-633527"}, {"role": "membership", "latex": "v,w \\in V"}], "hx/content": {"match": "$v,w \\in V$", "position": 817}, "hx/labels": ["scope", "set-notation"], "delta_status": "added"}], "stats": {"legacy_count": 4, "new_count": 9, "added_count": 5, "legacy_type_counts": {"bind/let": 2, "quant/universal": 1, "constrain/where": 1}, "new_type_counts": {"bind/let": 2, "quant/universal": 1, "constrain/where": 1, "constrain/such-that": 5}}, "paper_scope_case": {"arxiv_id": "0705.0462", "title": "Resource modalities in game semantics", "url": "https://arxiv.org/abs/0705.0462", "snippet": "\\ldots \\xrightarrow{m_{k-1}} x_{k-1} \\xrightarrow{m_k} x_k \\end{equation} % Two paths are parallel when they have the same initial and final positions. % A play~(\\ref{equation/play}) is \\emph{alternating} when: \\mathin \\forall i \\in \\{1 , \\ldots , k-1\\}, \\quad \\quad \\lambda_A(m_{i+1}) = - \\lambda_A(m_i). \\mathout % \\paragraph{{\\bf Strategy.}} % A strategy $\\sigma$ of a Conway game is defined as a set of alternating plays of even length such that: % \\begin{itemize} \\sitem $\\sigma$~contains the empty play, \\sitem every nonempty play starts with an Opponent move, \\sitem $\\sigma$ is closed by even-length prefix: for every play~$s$, and for all moves~$m,n$, $$ s \\cdot m \\cdot n \\in \\sigma \\Implie", "detected_env": "lemma", "detected_binder": "forall", "scope_type_top": [["constrain/such-that", 4], ["constrain/where", 2], ["assume/explicit", 1], ["env/lemma", 1]]}};

function esc(s) {
  return String(s)
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');
}

function renderHighlighted(text, scopes, clsFn) {
  const arr = [...scopes].sort((a,b) => {
    const pa = Number(a?.['hx/content']?.position ?? 1e12);
    const pb = Number(b?.['hx/content']?.position ?? 1e12);
    if (pa !== pb) return pa - pb;
    const la = String(a?.['hx/content']?.match ?? '').length;
    const lb = String(b?.['hx/content']?.match ?? '').length;
    return lb - la;
  });

  let out = '';
  let cur = 0;
  for (const s of arr) {
    const c = s['hx/content'] || {};
    const pos = Number(c.position ?? -1);
    const m = String(c.match ?? '');
    if (pos < 0 || !m) continue;
    if (pos < cur) continue;
    const end = Math.min(text.length, pos + m.length);
    if (pos > text.length || end <= pos) continue;
    out += esc(text.slice(cur, pos));
    const cls = clsFn(s);
    const tip = `${s['hx/type'] || '?'} @${pos}`;
    out += `<span class="${cls}" title="${esc(tip)}">${esc(text.slice(pos, end))}</span>`;
    cur = end;
  }
  out += esc(text.slice(cur));
  return out;
}

function buildStats() {
  const s = DATA.stats;
  const cards = [
    ['Legacy scopes', s.legacy_count],
    ['New scopes', s.new_count],
    ['Added scopes', s.added_count],
    ['Delta', s.new_count - s.legacy_count],
  ];
  document.getElementById('stats').innerHTML = cards.map(([k,v]) =>
    `<div class="stat"><div class="k">${esc(k)}</div><div class="v">${v}</div></div>`
  ).join('');
}

function buildTexts() {
  const text = DATA.thread.answer_text;
  const legacy = DATA.legacy_scopes;
  const news = DATA.new_scopes;
  document.getElementById('legacy-text').innerHTML = renderHighlighted(text, legacy, () => 'scope-legacy');
  document.getElementById('new-text').innerHTML = renderHighlighted(text, news, (s) =>
    s.delta_status === 'added' ? 'scope-added' : 'scope-common'
  );
}

function buildAddedTable() {
  const body = document.querySelector('#added-table tbody');
  const rows = DATA.added_scopes || [];
  if (!rows.length) {
    body.innerHTML = '<tr><td colspan="3">No added scopes in this thread.</td></tr>';
    return;
  }
  body.innerHTML = rows.map((s) => {
    const c = s['hx/content'] || {};
    return `<tr><td><code>${esc(s['hx/type'] || '?')}</code></td><td>${esc(c.match || '')}</td><td>${Number(c.position ?? -1)}</td></tr>`;
  }).join('');
}

function buildTypeDelta() {
  const legacy = DATA.stats.legacy_type_counts || {};
  const now = DATA.stats.new_type_counts || {};
  const keys = Array.from(new Set([...Object.keys(legacy), ...Object.keys(now)])).sort();
  const body = document.querySelector('#type-table tbody');
  body.innerHTML = keys.map((k) => {
    const a = Number(legacy[k] || 0);
    const b = Number(now[k] || 0);
    const d = b - a;
    const ds = d > 0 ? `+${d}` : `${d}`;
    return `<tr><td><code>${esc(k)}</code></td><td>${a}</td><td>${b}</td><td>${ds}</td></tr>`;
  }).join('');
}

function buildPaperCase() {
  const p = DATA.paper_scope_case || {};
  const meta = document.getElementById('paper-meta');
  const pre = document.getElementById('paper-snippet');
  if (p.error) {
    meta.textContent = p.error;
    pre.textContent = '';
    return;
  }
  const scopeTop = (p.scope_type_top || []).map(([t,n]) => `${t}:${n}`).join(', ');
  meta.innerHTML =
    `arXiv <code>${esc(p.arxiv_id || '')}</code> - ` +
    `<a href="${esc(p.url || '#')}" target="_blank">${esc(p.title || '')}</a> - ` +
    `env=<code>${esc(p.detected_env || '')}</code>, binder=<code>${esc(p.detected_binder || '')}</code><br>` +
    `Detected scope types: ${esc(scopeTop)}`;
  pre.textContent = p.snippet || '';
}

buildStats();
buildTexts();
buildAddedTable();
buildTypeDelta();
buildPaperCase();
</script>
</body>
</html>
